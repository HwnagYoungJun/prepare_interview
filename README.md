# 면접준비

## 기술 질문

### 1. 객체지향

#### 1-1 개요

> 프로그래밍 패러다임 중의 하나로, 필요한 데이터를 추상화 시켜 상태와 행위를 가지는 객체로 만들고, 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는프로그래밍 방법이다.



#### 1-2 장점

- 상속을 통한 재사용과 시스템의 확장이 용이하다.
- 코드의 재활용성이 높다.
- 자연적인 모델링에 의해 분석과 설계를 쉽고 효율적으로 할 수 잇다.
- 사용자와 개발자 사이의 이해를 쉽게 해준다.
- 대형 프로그램의 자성이 용이하다.
- 소프트웨어 개발 및 유지보수가 용이하다.



#### 1-3 특징

- 캡슐화
  - 데이터와 함수를 하나로 묶는 것을 의미
  - 내용이 은폐되어 변경이 발생 할 때 오류의 파급효과가 적다.
  - 캡슐화된 객체들은 재사용이 용이하다.
- 정보 은닉
  
  - 캡슐화에서 가장 중요한 개념, 다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통하여 접근을 허용하는 것이다.
- 추상화
  - 불필요한 생략하고 객체의 속성 중 가장 중요한 것에만 중점을 두어 개략화 하는것, 즉 모델화 하는것
  - 데이터의 공통된 성질을 추출하여 슈퍼 클래스를 선정하는 개념이다,.
- 상속성
  
  - 이미 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는것이다.
- 다형성
  - 메세지에 의해 객체가 연산을 수행하게 될 때 하나의 메시지에 대해 각 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력
  - 객체들은 동일한 메소드명을 사용하며 같은 의미의 응답을 한다.
  
  

#### 1-4 설계 원칙

1. SRP: 단일 책임원칙

   > 클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유여야 한다.

2. OCP: 개방-폐쇄 원칙

   > 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.

3. LSP: 리스코프 치환 원칙

   > 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.

4. ISP: 인터페이스 분리 원칙

   > 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야한다.

5. DIP: 의존 역전 원칙

   > 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.



#### 1-5 오버라이드, 오버로딩의 차이

1. 오버라이딩 : 상위 클래스가 가지고 있는 메소드를 하위 클래스에서 메소드를 재정의 하여 사용

   ```c#
   class Cat
   {
       public virtual void sound()
       {
           Console.WriteLine("Meow Meow");
       }
       
   }
   class Tiger : Cat
   {
       public override void sound()
       {
           Console.WriteLine("Roar Roar");
       }
   }
   class Program
   {
       static void Main(string[] args)
       {
           Cat cat = new Cat();
           Tiger tiger = new tiger();
           cat.sound();
           // "Meow Meow"
           tiger.sound();
           // "Roar Roar"
           ((Cat)tiger).sound();
           // "Roar Roar"
       }
   }
   ```

   

2. 오버로딩: 메서드의 이름은 동일하지만 매개변수의 유형을 다르게하여 만들어 사용

   ```c#
   class OverloadTest
   {
       public static void Method(int val)
       {
           Console.WriteLine("int");
       }
       public static void Method(string val)
       {
           Console.WriteLine("string!!");
       }
   }
   class Program
   {
       static void Main(string[] args)
       {
           OverloadTest.Method(123);
           // "int"
           OverloadTest.Method('hi hi');
           // "string"
       }
   }
   ```

#### 

#### 1-6 class, object, instance, interface

1. class

   - 객체를 만들어 내기 위한 설계도 혹은 틀
   - 연관되어 있는 변수와 메서드의 집합

2. object

   - 소프트웨어 세계에서 구현할대상
   - 클래스에 선언된 모양 그대로 생성된 실체

   - 클래스의 인스턴스라고도 부른다
   - 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖는다.

3. instance
   - 설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체
   - 즉, 객체를 소프트웨어에 실체화 하면 그것을 '인스턴스'라고 부른다.



##### 1-6-1 클래스 vs 객체

- 클래스는 `설계도` 객체는 `설계도로 구현한 모든 대상`을 의미한다.
- 붕어빵 -> 객체, 붕어빵기계 -> 클래스



##### 1-6-2 추상 클래스

- 추상적인 개념을 표현하고, 완성되지 않은 메서드를 가지고 있는 클래스
- 메서드가 미완성이기 때문에, 추상 클래스로는 개체를 생성할 수 없다.
- 추상 메서드를 하나라도 가지고 있으면 추상 클래스가 된다.
  - 추상메서드 : 동작 방식을 결정할 수 없을 때, 확정할 수 없는 경우, 동작부분을 기술하지 않고 비워두는 메서드

```c#
abstract class Animal
{
    public string name;
    public abstract void Move(); // 추상 메서드
    // 동물이란 개체에서 동물이 날지, 기어다닐지 확정할 수 없으므로 추상메서드로 만듬
    
    public void Move2() // 일반 메서드
    {
        Console.WriteLine("동물이 움직임");
    }
}

class Dog : Animal
{
    public override void Move() // 상위 클래스의 추상메서드를 오버라이드 시켜 사용
    {
        Console.WriteLine("네 발로 움직임");
    }
}
```



##### 1-6-3 인터페이스

- 추상 클래스처럼 완성되지 않은 불완전한 것이지만, 추상 클래스보다  추상화 정도가 높다
- 오직 추상 메서드와 상수만을 멤버로 가질 수 있다.
- 인터페이스는 다른 클래스를 작성하는데 도움을 줄 목적으로 작성된다.

- 인터페이스에 속한 메서드는 모두 가상메서드에 속한다. 따라서 virtual 키워드를 지정하지 못하게 막고 오버라이드도 막는다. 왜냐하면 굳이 이러한 키워드를 사용해서 표시할 필요가 없기 때문이다.
- 특징
  - 접근 제한자를 사용할 수 없고 모든 것이 public으로 선언된다.
  - 메서드, 프로퍼티, 인덱서, 이벤트만을 가질 수 있다.
  - 인터페이스는 new 연산자를 이용하여 인스턴스를 생성할 수 없지만 참조변수로는 만들 수 있다.

```C#
interface ILogger // 인터페이스
{
    void WriteLog(string log);
}
class consoleLogger : ILogger // 인터페이스를 구현한 클래스
{
    public void WriteLog(string log)
    {
        Console.WriteLine("{0} {1}", DateTime.Now.ToLocalTime(), log)
    }
}
```



##### 1-6-4 인터페이스와 추상 클래스의 비교

- 공통점
  - 스스로 객체를 생성할 수 없다.
  - 상속 관계에서만 존재한다.
- 차이점
  - 추상 클래스는 클래스로 정의 되었기 때문에 다중 상속을 할 수 없지만 인터페이스는 클래스가 아니기 때문에 다중상속이 허용된다.
  - 인터페이스는 일반메서드 및 변수를 가질 수 없다.



### 2. 운영체제

#### 2-1 프로세스

##### 2-1-1 정의

> CPU에 의해 수행되는 시스템 및 사용자 프로그램을 프로세스라고 하며 이는 시스템의 작업 단위로 프로그램에 입출력 상태를 결합한 형태이다.

##### 2-1-2 스레드(Thread)

> 프로세스의 구성을 실행부분과 실행환경 부분으로 나눌 때, 스레드는 프로세스의 실행부분을 담당하는 실행의 기본단위

- 프로세스 스케쥴링에 따른 컨텍스트 스위칭의 부담을 줄여 성능을 향상시키기 위한 프로세스의 다른 표현 방식
- 응답성 증가, 자원 공유, 경제성, 다중 처리기 구조의 활용

##### 2-1-2 프로세스 스케줄링

1. 비선점 스케쥴링

> 한 프로세스가 CPU를 할당받으면 CPU는 그 프로세스로부터 나올 수 없음

- FIFO, SJF, HRN
- 응답시간의 예측이 가능하다.

2. 선점 스케쥴링

> 한 프로세스가 CPU를 차지하고 있을 때 다른 프로세스가 현재 프로세스를 중지시키고 CPU를 차지할 수 있음

- RR
- SRT
- MLQ
- MFQ
- 선점 우선순위
- 컨텍스트 스위칭으로 인한 많은 오버헤드를 초래

##### 2-1-3 동기화

> 임계영역: 하나의 프로세스가 수정 가능한 공유 자원을 액세스 하고 있을 때, 그 프로세스에 의해 참조되는 프로글매의 부분

- 상호배제
- 제한된 대기
- 진행 조건

1. 동기화 기법(Synchronization)
   1. 세마포어
   2. 모니터

##### 2-1-4 교착상태

> 다중 프로그래밍 시스템에서 아무리 기다려도 결코 일어나지 않을 사건을 기다리고 있는 하나 또는 그 이상의 프로세스

- 교착상태의 4가지 필요조건

1. 상호배제
2. 점유와 대기
3. 비선점
4. 환형대기

- 해결방법
  1. 예방 - 필요조건 중 하나 이상을 부정
  2. 회피 - 안정/불 안정 상태(은행가 알고리즘)
  3. 발견 - 자원 할당 그래프
  4. 회복

#### 2-2 기억장치

##### 2-2-1 Gabage collection

1. Python
   - 파이썬에선 기본적으로 [garbage collection](https://docs.python.org/3/glossary.html#term-garbage-collection)(가비지 컬렉션)과 [reference counting](https://docs.python.org/3/glossary.html#term-reference-count)(레퍼런스 카운팅)을 통해 할당된 메모리를 관리한다. 기본적으로 참조 횟수가 0이 된 객체를 메모리에서 해제하는 레퍼런스 카운팅 방식을  사용하지만, 참조 횟수가 0은 아니지만 도달할 수 없지만, 상태인 reference cycles(순환 참조)가 발생했을 때는  가비지 컬렉션으로 그 상황을 해결한다.

2. C#
   - C, C++과는 다르게 수동으로 GC를 해줄필요는 없으며, 순환참조 외 참조가 0일경우 일정한 주기로 GC가 발생

##### 2-2 페이지 교체 기법

1. FIFO
   - 가장 간단한 알고리즘으로, 메모리에 올라온 지 가장 오래된 페이지를 교체한다.
   - 프레임이 커지면 부재율이 높아지는 벨레이디의 모순 현상이 일어난다.
2. OPT(최적 교체)
   - 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법이다.
   - 미리 예측해야 하므로 실현 가능성이 희박하다.
3. LRU
   - 최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법이다.
4. LFU
   - 사용 빈도가 가장 적은 페이지를 교체하는 기법이다.
   - 활발하게 사용되는 페이지는 사용횟수가 많아 교체되지 않고 사용된다.
   - 초기에 많이 사용된 페이지가 그 이후로 사용되지 않더라도 프레임을 계속 차지할 수 있다.
5. SCR(2차 기회교체)



### 3. 네트워크



## 비기술 질문

- 개발 공부를 시작한 계기
- 개발직무에 가장 필요하다고 생각하는 역량
  - 긍정적인 커뮤니케이션, 책임감





## 도움이 많이 되는 Github

1. https://github.com/JaeYeopHan/Interview_Question_for_Beginner
2. https://github.com/gyoogle/tech-interview-for-developer
3. https://github.com/qkraudghgh/coding-interview
4. https://github.com/GimunLee/tech-refrigerator

